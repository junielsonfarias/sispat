import { Request, Response } from 'express';
import { prisma } from '../index';

/**
 * ‚úÖ VERS√ÉO 2.0.6: Usa responsibleSectorIds (UUIDs) ao inv√©s de nomes
 * 
 * Esta vers√£o ser√° ativada ap√≥s aplicar a migration 03_responsible_sectors_ids.sql
 */

/**
 * Listar patrim√¥nios com filtros
 * GET /api/patrimonios
 * 
 * ‚úÖ MELHORIA v2.0.6: Usa sectorIds diretamente (sem buscar por nome)
 */
export const listPatrimonios = async (req: Request, res: Response): Promise<void> => {
  try {
    const {
      search,
      status,
      sectorId,
      tipo,
      page = '1',
      limit = '50',
    } = req.query;

    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const skip = (pageNum - 1) * limitNum;

    // Construir filtros
    const where: any = {
      municipalityId: req.user?.municipalityId,
    };

    // Filtro de busca
    if (search) {
      where.OR = [
        { numero_patrimonio: { contains: search as string, mode: 'insensitive' } },
        { descricao_bem: { contains: search as string, mode: 'insensitive' } },
      ];
    }

    // Filtro de status
    if (status) {
      where.status = status;
    }

    // Filtro de setor
    if (sectorId) {
      where.sectorId = sectorId;
    }

    // Filtro de tipo
    if (tipo) {
      where.tipoId = tipo;
    }

    // ‚úÖ FILTRO POR PERFIL (v2.0.6 - USA IDs DIRETAMENTE)
    // Admin e Supervisor: Veem TODOS os setores
    // Usuario e Visualizador: Apenas setores atribu√≠dos
    if (req.user?.role !== 'supervisor' && req.user?.role !== 'admin' && req.user?.role !== 'superuser') {
      const user = await prisma.user.findUnique({
        where: { id: req.user!.userId },
        select: { 
          responsibleSectors: true,  // ‚ö†Ô∏è Este campo ainda tem NOMES em v2.0.5
          responsibleSectorIds: true  // ‚úÖ Este campo tem IDs em v2.0.6
        },
      });

      console.log('üîç [v2.0.6] Verifica√ß√£o de acesso:', {
        userId: req.user?.userId,
        userRole: req.user?.role,
        responsibleSectorIds: user?.responsibleSectorIds,
        responsibleSectorsOLD: user?.responsibleSectors,
      });

      // ‚úÖ USAR responsibleSectorIds (array de UUIDs)
      if (user && user.responsibleSectorIds && user.responsibleSectorIds.length > 0) {
        where.sectorId = { in: user.responsibleSectorIds };
        console.log('‚úÖ [v2.0.6] Filtrando por sectorIds:', user.responsibleSectorIds);
      } else if (user && user.responsibleSectors && user.responsibleSectors.length > 0) {
        // ‚ö†Ô∏è FALLBACK: Se responsibleSectorIds vazio, usar m√©todo antigo
        console.warn('‚ö†Ô∏è [v2.0.6] FALLBACK: Usando responsibleSectors (nomes)');
        
        const sectors = await prisma.sector.findMany({
          where: { name: { in: user.responsibleSectors } },
          select: { id: true },
        });

        const sectorIds = sectors.map(s => s.id);
        
        if (sectorIds.length > 0) {
          where.sectorId = { in: sectorIds };
        }
      } else {
        console.log('‚ÑπÔ∏è [v2.0.6] Usu√°rio sem setores atribu√≠dos - mostrando TODOS');
      }
    }

    // Buscar patrim√¥nios
    const [patrimonios, total] = await Promise.all([
      prisma.patrimonio.findMany({
        where,
        skip,
        take: limitNum,
        orderBy: { createdAt: 'desc' },
        include: {
          sector: {
            select: { id: true, name: true, codigo: true },
          },
          local: {
            select: { id: true, name: true },
          },
          tipoBem: {
            select: { id: true, nome: true },
          },
          acquisitionForm: {
            select: { id: true, nome: true },
          },
          creator: {
            select: { id: true, name: true, email: true },
          },
        },
      }),
      prisma.patrimonio.count({ where }),
    ]);

    console.log('‚úÖ [v2.0.6] Patrim√¥nios encontrados:', patrimonios.length);

    res.json({
      patrimonios,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        pages: Math.ceil(total / limitNum),
      },
    });
  } catch (error) {
    console.error('‚ùå [v2.0.6] Erro ao listar patrim√¥nios:', error);
    res.status(500).json({ error: 'Erro ao listar patrim√¥nios' });
  }
};

/**
 * Helper: Verificar acesso do usu√°rio a um patrim√¥nio
 * 
 * ‚úÖ v2.0.6: Usa sectorIds diretamente
 */
export const checkPatrimonioAccess = async (
  userId: string,
  userRole: string,
  patrimonioSectorId: string
): Promise<boolean> => {
  // Admin, Supervisor e Superuser t√™m acesso total
  if (['admin', 'supervisor', 'superuser'].includes(userRole)) {
    return true;
  }

  // Usuario e Visualizador: verificar setores
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { 
      responsibleSectorIds: true,
      responsibleSectors: true  // Fallback
    },
  });

  if (!user) {
    return false;
  }

  // ‚úÖ Usar responsibleSectorIds (v2.0.6)
  if (user.responsibleSectorIds && user.responsibleSectorIds.length > 0) {
    return user.responsibleSectorIds.includes(patrimonioSectorId);
  }

  // ‚ö†Ô∏è FALLBACK: Usar m√©todo antigo (v2.0.5)
  if (user.responsibleSectors && user.responsibleSectors.length > 0) {
    const sector = await prisma.sector.findUnique({
      where: { id: patrimonioSectorId },
      select: { name: true },
    });

    if (sector) {
      return user.responsibleSectors.includes(sector.name);
    }
  }

  // Se n√£o tem setores atribu√≠dos, tem acesso (modo configura√ß√£o)
  return true;
};

/**
 * EXPORT para uso em outros controllers
 */
export const patrimonioHelpers = {
  checkPatrimonioAccess,
};

