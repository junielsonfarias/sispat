import rateLimit from 'express-rate-limit'
import RedisStore from 'rate-limit-redis'
import Redis from 'ioredis'

// Cliente Redis para rate limiting
const redis = process.env.REDIS_URL
  ? new Redis(process.env.REDIS_URL)
  : null

/**
 * Rate limiter global para toda a API
 * 100 requests por 15 minutos por IP
 */
export const globalRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // 100 requests
  standardHeaders: true,
  legacyHeaders: false,
  
  // Usar Redis se dispon√≠vel, sen√£o mem√≥ria
  store: redis
    ? new RedisStore({
        // @ts-expect-error - tipos do RedisStore
        sendCommand: (...args: string[]) => redis.call(...args),
        prefix: 'rl:global:',
      })
    : undefined,
  
  message: {
    error: 'Muitas requisi√ß√µes deste IP. Tente novamente em alguns minutos.',
    retryAfter: 'Dispon√≠vel novamente em',
  },
  
  // N√£o aplicar rate limit em health checks
  skip: (req) => {
    return req.path.startsWith('/api/health') || req.path.startsWith('/health')
  },
  
  // Handler customizado para quando exceder
  handler: (req, res) => {
    console.warn(`‚ö†Ô∏è Rate limit exceeded: ${req.ip} ‚Üí ${req.path}`)
    
    res.status(429).json({
      error: 'Too Many Requests',
      message: 'Voc√™ excedeu o limite de requisi√ß√µes. Tente novamente mais tarde.',
      retryAfter: Math.ceil(req.rateLimit.resetTime! / 1000),
    })
  },
})

/**
 * Rate limiter para autentica√ß√£o (prote√ß√£o contra brute force)
 * 5 tentativas por 15 minutos
 */
export const authRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  standardHeaders: true,
  legacyHeaders: false,
  
  store: redis
    ? new RedisStore({
        // @ts-expect-error - tipos do RedisStore
        sendCommand: (...args: string[]) => redis.call(...args),
        prefix: 'rl:auth:',
      })
    : undefined,
  
  message: {
    error: 'Muitas tentativas de login. Aguarde 15 minutos.',
  },
  
  handler: (req, res) => {
    console.error(`üö® Poss√≠vel brute force attack: ${req.ip} ‚Üí ${req.body?.email || 'unknown'}`)
    
    res.status(429).json({
      error: 'Too Many Requests',
      message: 'Muitas tentativas de login. Por seguran√ßa, aguarde 15 minutos.',
      retryAfter: Math.ceil(req.rateLimit.resetTime! / 1000),
    })
  },
})

/**
 * Rate limiter para opera√ß√µes de escrita (POST/PUT/DELETE)
 * 30 requests por minuto
 */
export const writeRateLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minuto
  max: 30,
  standardHeaders: true,
  legacyHeaders: false,
  
  store: redis
    ? new RedisStore({
        // @ts-expect-error - tipos do RedisStore
        sendCommand: (...args: string[]) => redis.call(...args),
        prefix: 'rl:write:',
      })
    : undefined,
  
  message: 'Limite de opera√ß√µes de escrita excedido. Aguarde alguns segundos.',
  
  // Aplicar apenas em m√©todos de escrita
  skip: (req) => req.method === 'GET',
})

/**
 * Rate limiter para uploads de arquivo
 * 10 uploads por hora
 */
export const uploadRateLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 10,
  standardHeaders: true,
  legacyHeaders: false,
  
  store: redis
    ? new RedisStore({
        // @ts-expect-error - tipos do RedisStore
        sendCommand: (...args: string[]) => redis.call(...args),
        prefix: 'rl:upload:',
      })
    : undefined,
  
  message: 'Limite de uploads excedido. Aguarde antes de enviar mais arquivos.',
})

/**
 * Rate limiter para gera√ß√£o de relat√≥rios/PDFs
 * 20 por hora (opera√ß√µes custosas)
 */
export const reportRateLimiter = rateLimit({
  windowMs: 60 * 60 * 1000,
  max: 20,
  standardHeaders: true,
  legacyHeaders: false,
  
  store: redis
    ? new RedisStore({
        // @ts-expect-error - tipos do RedisStore
        sendCommand: (...args: string[]) => redis.call(...args),
        prefix: 'rl:report:',
      })
    : undefined,
  
  message: 'Limite de gera√ß√£o de relat√≥rios excedido. Aguarde alguns minutos.',
})

// Helper para verificar se Redis est√° dispon√≠vel
export const isRedisAvailable = (): boolean => {
  return redis !== null && redis.status === 'ready'
}

// Log de status do Redis
if (redis) {
  redis.on('connect', () => console.log('‚úÖ Redis conectado para rate limiting'))
  redis.on('error', (err) => console.error('‚ùå Redis error:', err))
  redis.on('ready', () => console.log('‚úÖ Redis pronto para rate limiting'))
} else {
  console.warn('‚ö†Ô∏è Redis n√£o configurado. Rate limiting usando mem√≥ria (n√£o distribu√≠do)')
}

export default {
  globalRateLimiter,
  authRateLimiter,
  writeRateLimiter,
  uploadRateLimiter,
  reportRateLimiter,
  isRedisAvailable,
}

